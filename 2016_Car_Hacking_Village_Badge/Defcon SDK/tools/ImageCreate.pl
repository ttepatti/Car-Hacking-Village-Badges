#!/usr/bin/perl
#
# Copyright 2016 Specialized Solutions LLC
# 
# Title to the Materials (contents of this file) remain with Specialized
# Solutions LLC.  The Materials are copyrighted and are protected by United
# States copyright laws.  Copyright notices cannot be removed from the
# Materials.
#
# See the file titled "Specialized Solutions LLC License Agreement.txt"
# that has been distributed with this file for further licensing details.
#
# Builds a PAWN file to display the specified RGB 565 image.
#
# See the file named "ImageCreate.txt" for more details on how to use.
#
# Strawberry Perl is good to use on Windows.  This should work without 
# installing any packages.
#
# Some people hate me for using Perl, some love me for it.  I use it because
# it just works so well for stuff like this :-) (esp. unpack and pack).  
# It should be pretty easy to convert this to use any language you want to use.
#
#
use Getopt::Long;
use Data::Dumper;
use File::Slurp;

#
#parse the command line options
#
my $help = " current options are:
   --in <my_image.bmp>
   \n";

GetOptions('in=s' => \$inFile);

if (defined($inFile))
{
    $IN_FILE = $inFile;
    undef $inFile;
}
else
{
    print $help and die;
}

print $IN_FILE . "\n";

my $image_data = read_file($IN_FILE, { binmode => ':raw' });
my ($header, $image_size_bytes, $temp, $temp2, $image_offset, $temp3, $image_width, $image_height)  = unpack("vVvvVVVV", $image_data);

#strip off the header to get to the pixel data 
$image_data = substr($image_data, $image_offset);

my @image = unpack("v*", $image_data);

print "Image Size Pixels: " . scalar(@image) . "\n";
print "Image Calc Pixels: " . $image_height * $image_width . "\n";

#get file name 
my $image_name = $IN_FILE;

$image_name =~ s/\..*//g;

open($fh,">$image_name.p") or die "Could not open $image_name.p for writing";

print $fh "
/******************************************************************************
 * Autogenerated File - Only edit image_origin_x_right and  image_origin_y_top
 *****************************************************************************/
";

print $fh "
new const " . $image_name . "_DATA[] = [";

# BMP files are stored starting at lower left corner, scanning left then update
# this display needs them reversed (both x and y)
# note that BMP files also pad to 4-byte alignment per row, which will need to 
# be taken into account
my @image_reverse = reverse(@image);

$image_offset = 0;
my @pixel_data = ();

for ($y = 0; $y < $image_height; $y++)
{
	if ((($image_width * 2) % 4) != 0)
	{
		#drop padding at start of row 
		$image_offset++;
	}
	
	for ($x = $image_width; $x > 0; $x--)
	{
		push(@pixel_data, $image_reverse[$image_offset + $x - 1]);
	}
	
	$image_offset += $image_width;
}

print "Pixel Data Size  : " . scalar(@pixel_data) . "\n";

#dump the data to the pawn file 
for ($i = 0; $i < scalar(@pixel_data); $i += 2)
{	
	if (($i % 16) == 0)
	{
		print $fh "\n	";
	}
	
	if (($i + 1) < scalar(@pixel_data))
	{
		printf $fh "0x%04X%04X", $pixel_data[$i], $pixel_data[$i + 1];
	}
	else
	{
		printf $fh "0x%04X0000", $pixel_data[$i];
	}
	
	if (($i + 2) < scalar(@pixel_data))
	{
		print $fh ", ";
	}
}

print $fh "
]
	
stock display_$image_name()
{
";

printf $fh "
	new const image_width = %d
	new const image_height = %d
	new const image_origin_x_right = 0
	new const image_origin_y_top = 0

", $image_width, $image_height;

print $fh "
	
	qcm_display_write_const_buffer(image_origin_x_right, image_origin_y_top, 
	image_origin_x_right + image_width - 1, image_origin_y_top + image_height - 1,
	" . $image_name . "_DATA, image_width * image_height)
		
}

";

close $fh;



